---
title: Why your react app is slow, and why useMemo won't fix it.
date: 2025-12-02
description: In the era of AI slop react code, a fast app is hard to come by. Even experienced devs have a hard time doing it right. In this post, we'll explore why your react app is slow, and why useMemo or other duck-tape solutions won't fix it.
image: https://cdn.midjourney.com/d719ca3c-7ea2-4634-bb4f-ab5a03f5a568/0_0.png
---

In the era of AI slop react code, creating an app is faster than ever, but creating a fast app is harder than ever. Even experienced devs have a hard time doing it right and tend to overcomplicated things with _duct-tape solutions_, the `Just one more useMemo bro, trust` mindset. In this post, we'll explore why your react app is slow, and why useMemo or other _duct-tape solutions_ won't fix it and what some common anti-patterns are that you should avoid and how to think about performance in general.

These points are mainly coming from my learnings working at [@Midjourney](https://www.midjourney.com), where I've had the pressure to work with some amazing devs, primarily [Cheng Lou](https://x.com/_chenglou) and [Benjamin San Souci](https://x.com/bsansouci). The Midjourney website serves millions of users a month and is maintained by ~5 full time engineers.

There are 6 main points I want to cover in this post:

1. Rerenders are not the enemy
2. Data structures are the key to performance, you should try to _actually_ think about it
3. State management is key.
4. Why **useMemo** or **useCallback** won't fix it.
5. Dependency hell is probably slowing you down, keeping it lean will save you headaches
6. Web dev is easy, you are making it hard.

## Why **useMemo** or **useCallback** won't fix it.

When people's apps become slow, they tend to go into panic mode and just slap a **useMemo** or **useCallback** on anything they can find praying to the JavaScript gods that it will work. More often than not, they also use **useMemo** and **useCallback** before even getting a performance issue in the spirit of `this might be slow, so might be good to memo it just because`.

If I got a penny for every time I've seen code like this I might finally be able to pay my Vercel bill:

```tsx {2-2, 7-7, 11-11}
const UserComponent = ({ age, userArray }) => {
	const name = useMemo(() => {
		if (age > 21) return 'unc'
		return 'noob'
	}, [])

	const hasMatheus = useMemo(() => {
		return userArray.some((user) => user.name === 'matheus')
	}, [userArray])

	const getNames = useCallback(() => {
		return userArray.map((user) => user.name)
	}, [userArray])
}
```

There are a couple of issues with code like this. To begin, take the first **useMemo** example here, the check for `age > 21` is basically free already and adding the **useMemo** does nothing in practice. It's easy to feel like hooks are these magical things but they are really not, they are normal JavaScript functions and have their own code to run that is very much not free, so in this case you probably made your app objectively slower as the `>` check is less computationally heavy than invocation of `useMemo`.

The second `useMemo` might seem more reasonable, but it's probably not. It for sure depends on the full context here to say if this `useMemo` makes sense or not, but some good rules of thumb are:

1. Does `userArray` have `< 1000` items? It's most likely fine to iterate over on each render and does not need a `useMemo`
2. Is `UserComponent` used once per screen or can it be used hundreds at the same time? If it's only used once, it's fine, if it's many times the `useMemo` won't really help due to it still needing to compute it for each component, so you end up with a `N*M` issue where `N` is the length of `userArray` and `M` is the number of components, so you should probably hoist up the `hasMatheus` calculation one level up in the component tree and remove the `useMemo`
3. Are you just doing a simple calculation, for example `x > y`, `x + y`, `array.length`, `someBoolean ? { foo } : { bar }`, you should simply never use `useMemo` for that.

The times that you actually want to use `useMemo` is usually for heavy instantiations of objects, think initializing an amplitude object for tracking events.

Circling back to the third code example there with the `useCallback`, this is a funny one and I've honestly seen this _soooo_ many times and my only logical reason as to why I believe people use `useCallback` is that either it's simply just AI slop and they have no clue how to write code so they just accept it, or they simply think that the hook "caches" the response of the function calculation and so that makes the function _blazingly faaast_. `useCallback` only really has two cases where it makes sense to use which is either if the function is used as a dependency in a `useEffect` or `useMemo`, or when you have a function that you need to pass as a prop to another component and that entire component is `memoized` which means it will only re-run once the props change.

Another case where I see people justify using `useMemo` is when they have some hook that is used in many places

The problem with wrapping you hooks in **useMemo** calls everywhere is that most of the time its some data manipulation that is usually based on some array coming from a prop that is not referentially stable, meaning the actual array object is different on each render, so the **useMemo** is basically useless. Another issue is that this mentally is sort of just trying to sweep the problems under the rug adn eventually it will catch up to you. If you have 10 pieces of state all wrapped in **useMemo** calls and that are like a chain depending on each other, as soon as one of them changes, all of them will re-run and you will hit freeze frames in your app.

There are a couple of easy fall pits here, and it generally just is about the state management of you app.

1. You are fetching the wrong data format, and overcompensating for it.
2. You have crazy state chains that can just simple be in a big context.

For point one this is usually when you have code like this:

```tsx
const SomeComponent = () => {
	const { data } = useQuery(()=> {
		return fetch('https://api.example.com/data')
	})

	return <DataComponent data={data} />
}

const DataComponent = ({ data }) => {
	const formattedData = useMemo(() => {
		return data.map((item) => ({...item, isAdult: item.age > 21}))
	}, [data])

	return ...
}
```

This is a _veeery_ common pattern I see in code bases where basically there is some data you are fetching from the backend that is not exactly what you need, but you pass it around to other components that then need it in some other way so they for example use a _.map()_ or _.filter()_ on it and then the developer thinks, `"Oh this might be expensive, I should probably memo it! ðŸ¤“â˜ï¸"`. The problem here is that this very easily gets out of hand as the complexity grows and more components start to depend on the data. The patter you want to follow is to try and fetch the data at the highest common level possible and then in the actuall fetch just tranform the data to what you need. This makes code first of all more readable as its easy to see where you fetched the data is also where the format of it is defined, but you don't need to add a **useMemo** call. So in this case it would look like this:

```tsx
const SomeComponent = () => {
	const { data } = useQuery(()=> {
		const fetchedData = fetch('https://api.example.com/data')
		return fetchedData.map((item) => ({...item, isAdult: item.age > 21}))
	})

	return <DataComponent data={data} />
}

const DataComponent = ({ data }) => {
	return ...
}
```

## Rerenders are not the enemy

When I look at other codebases one of the biggest patterns I see is that devs do everything in their power to avoid rerenders. They split up their components so that all of them do not re-render,
