---
title: Why your react app is slow, and why useMemo won't fix it.
date: 2025-12-02
description: In the era of AI slop react code, a fast app is hard to come by. Even experienced devs have a hard time doing it right. In this post, we'll explore why your react app is slow, and why useMemo or other duck-tape solutions won't fix it.
image: https://cdn.midjourney.com/d719ca3c-7ea2-4634-bb4f-ab5a03f5a568/0_0.png
---

In the era of AI slop react code, creating an app is faster than ever, but creating a fast app is harder than ever. Even experienced devs have a hard time doing it right and tend to overcomplicate things with _duct-tape solutions_, the `Just one more useMemo bro, trust` mindset. In this post, we'll explore why your react app is slow, and why useMemo or other _duct-tape solutions_ won't fix it and what some common anti-patterns are that you should avoid and how to think about performance in general.

These points are mainly coming from my learnings working at [@Midjourney](https://www.midjourney.com), where I've had the pressure to work with some amazing devs, primarily [Cheng Lou](https://x.com/_chenglou) and [Benjamin San Souci](https://x.com/bsansouci). The Midjourney website serves millions of users a month and is maintained by ~5 full time engineers.

There are 4 main points I want to cover in this post:

1. Rerenders are not the enemy
2. Data structures are the key to performance, you should try to _actually_ think about it
3. State management is key.
4. Why **useMemo** or **useCallback** won't fix it.
5. Dependency hell is probably slowing you down, keeping it lean will save you headaches
6. Web dev is easy, you are making it hard.

## Why **useMemo** or **useCallback** won't fix it.

When people's apps become slow, they tend to go into panic mode and just slap a **useMemo** or **useCallback** on anything they can find praying to the JavaScript gods that it will work. More often than not, they also use **useMemo** and **useCallback** before even getting a performance issue in the spirit of `this might be slow, so might be good to memo it just because`.

If I got a penny for every time I've seen code like this I might finally be able to pay my Vercel bill:

```tsx aa.tsx {2,4-6}
const UserComponent = ({ age, userArray }) => {
	const name = useMemo(() => {
		if (age > 21) return 'unc'
		return 'noob'
	}, [])

	const hasMatheus = useMemo(() => {
		return userArray.some((user) => user.name === 'matheus')
	}, [userArray]) // [!code hl:4]

	const getNames = useCallback(() => {
		return userArray.map((user) => user.name)
	}, [userArray])
}
```

There are a couple of issues with code like this. To begin, take the first **useMemo** example here, the check for `age > 21` is basically free. It's easy to feel like hooks are these magical things but they are really not, they are normal JavaScript functions and have their own code to run that is very much not free, so in this case you probably made your app objectively slower as the `>` check is less computationally heavy than invocation of `useMemo`.

The second `useMemo` might seem more reasonable, but it's probably not. It for sure depends on the full context here to say if this `useMemo` makes sense or not, but some good rules of thumb are:

1. Does `userArray` have `< 1000` items? It's most likely fine to iterate over on each render and does not need a `useMemo`
2. Is `UserComponent` used once per screen or can it be used hundreds at the same time? If it's only used once, it's fine, if it's many times the `useMemo` won't really help due to it still needing to compute it for each component, so you end up with a `N*M` issue where `N` is the length of `userArray` and `M` is the number of components, so you should probably hoist up the `hasMatheus` calculation one level up in the component tree and remove the `useMemo`
3. Are you just doing a simple calculation, for example `x > y`, `x + y`, `array.length`, `someBoolean ? { foo } : { bar }`, you should simply never use `useMemo` for that.

The times that you actually want to use `useMemo` is usually for heavy instantiations of objects, think initializing an amplitude object for tracking events.

Circling back to the third code example there with the `useCallback`, this is a funny one and I've honestly seen this _soooo_ many times and my only logical reason as to why I believe people use `useCallback` is that either it's simply just AI slop and they have no clue how to write code so they just accept it, or they simply think that the hook "caches" the response of the function calculation and so that makes the function _blazingly faaast_. `useCallback` only really has two cases where it makes sense to use which is either if the function is used as a dependency in a `useEffect` or `useMemo`, or when you have a function that you need to pass as a prop to another component and that entire component is `memoized` which means it will only re-run once the props change.

Another case where I see people justify using `useMemo` is when they have some hook that is used in many places

## Rerenders are not the enemy

When I look at other codebases one of the biggest patterns I see is that devs do everything in their power to avoid rerenders. They split up their components so that all of them do not re-render,
